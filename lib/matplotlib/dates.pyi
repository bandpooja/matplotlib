import datetime
import numpy as np
from typing import Any, Callable, Dict, List, Optional, Sequence, Union

from .axis import Axis
from .projections.polar import _AxisWrapper
from .ticker import _DummyAxis, Formatter, Locator
from .units import AxisInfo, ConversionInterface


# --- Global Functions ---

def _get_tzinfo(tz: Optional[Union[str, datetime.tzinfo]] = ...) -> datetime.tzinfo: ...

def _reset_epoch_test_example() -> None: ...

def set_epoch(epoch: str) -> None: ...

def get_epoch() -> str: ...

def _dt64_to_ordinalf(d: Union[np.datetime64, np.ndarray]) -> Union[float, np.ndarray]: ...

def _from_ordinalf(x: float, tz: Optional[Union[str, datetime.tzinfo]] = ...) -> datetime.datetime: ...

def datestr2num(d: Union[str, Sequence[str]], default: Optional[datetime.datetime] = ...) -> Union[float, np.ndarray]: ...

def date2num(d: Union[datetime.datetime, np.datetime64, Sequence[Union[datetime.datetime, np.datetime64]]]) -> Union[float, np.ndarray]: ...

def num2date(x: Union[float, Sequence[float]], tz: Optional[Union[str, datetime.tzinfo]] = ...) -> Union[datetime.datetime, list[datetime.datetime]]: ...

def num2timedelta(x: Union[float, Sequence[float]]) -> Union[datetime.timedelta, list[datetime.timedelta]]: ...

def drange(dstart: datetime.datetime, dend: datetime.datetime, delta: datetime.timedelta) -> np.ndarray: ...

def _wrap_in_tex(text: str) -> str: ...

# --- Formatter Classes ---

class DateFormatter(Formatter):
    tz: Optional[Union[str, datetime.tzinfo]]
    fmt: str
    _usetex: Optional[bool]

    def __init__(self, fmt: str, tz: Optional[Union[str, datetime.tzinfo]] = None, *, usetex: Optional[bool] = None) -> None: ...
    def __call__(self, x: float, pos: Optional[int] = 0) -> str: ...
    def set_tzinfo(self, tz: Optional[Union[str, datetime.tzinfo]]) -> None: ...

class ConciseDateFormatter(Formatter):
    _locator: Locator
    _tz: Optional[Union[str, datetime.tzinfo]]
    formats: List[str]
    zero_formats: List[str]
    offset_formats: List[str]
    offset_string: str
    show_offset: bool
    _usetex: Optional[bool]

    def __init__(self, locator: Locator,
                 tz: Optional[Union[str, datetime.tzinfo]] = None,
                 formats: Optional[Sequence[str]] = None,
                 offset_formats: Optional[Sequence[str]] = None,
                 zero_formats: Optional[Sequence[str]] = None,
                 show_offset: bool = True,
                 *, usetex: Optional[bool] = None) -> None: ...
    def __call__(self, x: float, pos: Optional[int] = 0) -> str: ...
    def format_ticks(self, values: Sequence[float]) -> List[str]: ...
    def get_offset(self) -> str: ...
    def format_data_short(self, value: float) -> str: ...

class AutoDateFormatter(Formatter):
    _locator: Locator
    _tz: Optional[Union[str, datetime.tzinfo]]
    defaultfmt: str
    _formatter: DateFormatter
    _usetex: Optional[bool]
    scaled: dict

    def __init__(self, locator: Locator,
                 tz: Optional[Union[str, datetime.tzinfo]] = None,
                 defaultfmt: str = '%Y-%m-%d',
                 *, usetex: Optional[bool] = None) -> None: ...
    def _set_locator(self, locator: Locator) -> None: ...
    def __call__(self, x: float, pos: Optional[int] = 0) -> str: ...

# --- rrulewrapper (assuming it's in rrule.py and this is its stub) ---
class rrulewrapper:
    def __init__(self, freq: int, tzinfo: Optional[datetime.tzinfo] = None, **kwargs: Any) -> None: ...
    def set(self, **kwargs: Any) -> None: ...
    def _update_rrule(self, **kwargs: Any) -> None: ...
    def _attach_tzinfo(self, dt: datetime.datetime, tzinfo: datetime.tzinfo) -> datetime.datetime: ...
    def _aware_return_wrapper(self, f: Callable[..., Any], returns_list: bool = False) -> Callable[..., Any]: ...
    def __getattr__(self, name: str) -> Any: ...
    def __setstate__(self, state: dict) -> None: ...

# --- Locator Classes ---

class DateLocator(Locator):
    hms0d: dict[str, int]

    def __init__(self, tz: Optional[datetime.tzinfo] = None) -> None: ...
    def set_tzinfo(self, tz: Optional[datetime.tzinfo]) -> None: ...
    def datalim_to_dt(self) -> tuple[datetime.datetime, datetime.datetime]: ...
    def viewlim_to_dt(self) -> tuple[datetime.datetime, datetime.datetime]: ...
    def _get_unit(self) -> float: ...
    def _get_interval(self) -> int: ...
    def nonsingular(self, v0: float, v1: float) -> tuple[float, float]: ...

class RRuleLocator(DateLocator):
    def __init__(self, o: rrulewrapper, tz: Optional[datetime.tzinfo] = None) -> None: ...
    def __call__(self) -> List[float]: ...
    def tick_values(self, vmin: float, vmax: float) -> List[float]: ...
    def _create_rrule(self, vmin: datetime.datetime, vmax: datetime.datetime) -> tuple[datetime.datetime, datetime.datetime]: ...
    def _get_unit(self) -> float: ...
    @staticmethod
    def get_unit_generic(freq: int) -> float: ...
    def _get_interval(self) -> int: ...

class AutoDateLocator(DateLocator):
    def __init__(self, tz: Optional[Union[str, datetime.tzinfo]] = None, minticks: int = 5,
                 maxticks: Optional[Union[int, Dict[int, int]]] = None,
                 interval_multiples: bool = True) -> None: ...
    def __call__(self) -> List[float]: ...
    def tick_values(self, vmin: float, vmax: float) -> List[float]: ...
    def nonsingular(self, v0: float, v1: float) -> tuple[float, float]: ...
    def _get_unit(self) -> float: ...
    def get_locator(self, dmin: datetime.datetime, dmax: datetime.datetime) -> RRuleLocator: ...


class YearLocator(RRuleLocator):
    def __init__(self, base: int = 1, month: int = 1, day: int = 1,
                 tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...
    def _create_rrule(self, vmin: datetime.datetime, vmax: datetime.datetime) -> tuple[datetime.datetime, datetime.datetime]: ...


class MonthLocator(RRuleLocator):
    def __init__(self, bymonth: Optional[Union[int, List[int]]] = None,
                 bymonthday: int = 1, interval: int = 1,
                 tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...

class WeekdayLocator(RRuleLocator):
    def __init__(self, byweekday: Union[int, List[int]] = 1, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...


class DayLocator(RRuleLocator):
    def __init__(self, bymonthday: Optional[Union[int, List[int]]] = None, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...


class HourLocator(RRuleLocator):
    def __init__(self, byhour: Optional[Union[int, List[int]]] = None, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...


class MinuteLocator(RRuleLocator):
    def __init__(self, byminute: Optional[Union[int, List[int]]] = None, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...


class SecondLocator(RRuleLocator):
    def __init__(self, bysecond: Optional[Union[int, List[int]]] = None, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...


class MicrosecondLocator(DateLocator):
    def __init__(self, interval: int = 1, tz: Optional[Union[str, datetime.tzinfo]] = None) -> None: ...
    def set_axis(self, axis: Union[Axis, _DummyAxis, _AxisWrapper, None]) -> None: ...
    def __call__(self) -> List[float]: ...
    def tick_values(self, vmin: float, vmax: float) -> Sequence[float]: ...
    def _get_unit(self) -> float: ...
    def _get_interval(self) -> int: ...

# --- Converter Classes ---

class DateConverter(ConversionInterface):
    def __init__(self, *, interval_multiples: bool = True) -> None: ...
    @staticmethod
    def axisinfo(unit: Optional[datetime.tzinfo], axis: Axis) -> None: ...
    @staticmethod
    def convert(obj: Union[datetime.datetime, datetime.date, float, np.datetime64, Sequence[Union[datetime.datetime, datetime.date, float, np.datetime64]]],
                unit: Optional[datetime.tzinfo], axis: Axis) -> Union[float, np.ndarray]: ...
    @staticmethod
    def default_units(x: Union[datetime.datetime, datetime.date, float, np.ndarray, Sequence[Union[datetime.datetime, datetime.date, float, np.datetime64]]],
                      axis: Axis) -> None: ...


class ConciseDateConverter(DateConverter):
    def __init__(self, formats: Optional[List[str]] = None, zero_formats: Optional[List[str]] = None,
                 offset_formats: Optional[List[str]] = None,
                 show_offset: bool = True, *, interval_multiples: bool = True) -> None: ...
    @staticmethod
    def axisinfo(unit: Optional[datetime.tzinfo], axis: Axis) -> None: ...


class _SwitchableDateConverter:
    @staticmethod
    def _get_converter() -> Union["ConciseDateConverter", "DateConverter"]: ...
    @staticmethod
    def axisinfo(unit: Optional[datetime.tzinfo], axis: Axis) -> AxisInfo: ...
    @staticmethod
    def default_units(x: Union[datetime.datetime, datetime.date, float, np.ndarray, Sequence[Union[datetime.datetime, datetime.date, float, np.datetime64]]],
                      axis: Axis) -> Optional[datetime.tzinfo]: ...
    @staticmethod
    def convert(value: Union[datetime.datetime, datetime.date, float, np.datetime64, Sequence[Union[datetime.datetime, datetime.date, float, np.datetime64]]],
                unit: Optional[datetime.tzinfo], axis: Axis) -> Union[float, np.ndarray]: ...
